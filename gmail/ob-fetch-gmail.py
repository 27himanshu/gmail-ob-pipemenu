#!/usr/bin/env python
#
# Python script to read emails from gmail using imaplib.
# It retrieves NUMBER_OF_MAILS from gmail and store them in CACHE_FILE.
# This file is then used to display emails in a openbox pipe menu.
# Thanks to https://gist.github.com/robulouski/7441883 for the base of this script
# Edit the following variables EMAIL_ACCOUNT, PASSWORD and NUMBER_OF_MAILS
# Format of the ob-cache-gmail generated by this script is as follows:
# First line of the file contains Unread email count
# Then for every next 3 lines contain info about an email: First line is subject, Second is Date and Third line is a url to that email
#

import sys
import imaplib
import email
import email.header
import datetime
import codecs
import os
from apscheduler.schedulers.blocking import BlockingScheduler

EMAIL_ACCOUNT = "your.username@gmail.com"
PASSWORD = "your.password"
FOLDER = "INBOX"
NUMBER_OF_MAILS=20
FETCH_INTERVAL=900  # Fetch interval in seconds
CACHE_FILE=".ob-cache-gmail"
DIR=os.path.dirname(os.path.realpath(sys.argv[0])) # Path to directory of script





Mail=None
def process_mailbox():
    if(Mail==None):
        print("Please run script as {} -d first".format(sys.argv[0]))
        sys.exit(1)
    print("Processing Now")
    mailfile = codecs.open(DIR+'/'+CACHE_FILE,'w','utf-8')
    result, data = Mail.uid('search', None, "ALL")
    u_result, unread_mails = Mail.uid('search', None, "UNSEEN")
    Unread = len(unread_mails[0].split())
    mailfile.write("Unread Emails: {}\n".format(Unread))
    if result != 'OK':
        print("No messages found!")
        return

    for index, num in enumerate(data[0].split()[:-(NUMBER_OF_MAILS+1):-1]):
        result, data = Mail.uid('fetch', num, '(RFC822)')
        if result != 'OK':
            print("ERROR getting message", num)
            return
        msg = email.message_from_bytes(data[0][1])
        Subject = email.header.decode_header(msg['Subject'])[0]
        Subject = Subject[0]
        if (not (type(Subject) is str)):
            Subject=Subject.decode("utf-8")
        Subject=Subject.replace('&','&amp;').replace('\"','&quot;').replace('\'','&apos;').replace('_','__')
        #From=email.utils.parseaddr(msg['From'])
        # Writing Subject to the file
        mailfile.write("{0}. {1}\n".format(index+1, Subject))
        # Writing date of mail to file
        date_tuple = email.utils.parsedate_tz(msg['Date'])
        if date_tuple:
            local_date = datetime.datetime.fromtimestamp(
                email.utils.mktime_tz(date_tuple))
            mailfile.write(local_date.strftime(" %d %b,%I:%M:%P")+"\n")
        # Writing link to the mail
        result, xgm = Mail.uid('fetch', num, 'X-GM-THRID')
        xgm=xgm[0].decode('utf-8')
        mailfile.write("https://mail.google.com/mail/u/0/#all/{}\n".format(format(int(xgm[15:34]),'x')))

    mailfile.close()
    print("Done")

def initiate():
    global Mail
    Mail = imaplib.IMAP4_SSL('imap.gmail.com')
    try:
        result, data = Mail.login(EMAIL_ACCOUNT, PASSWORD)
    except imaplib.IMAP4.error:
        print("LOGIN FAILED")
        sys.exit(1)
    print(result, data)
    result, data = Mail.select(FOLDER, readonly=True)
    if result == 'OK':
        print("OK, will process mailbox")
    else:
        print("ERROR: Accessing mailbox", result)


if __name__=="__main__":
    if len(sys.argv)==1:
        initiate()
        process_mailbox()
        sys.exit(0)
    else:
        if sys.argv[1]=='-d':
            initiate()
            sched = BlockingScheduler()
            sched.add_job(process_mailbox, 'interval', seconds=FETCH_INTERVAL)
            try:
                sched.start()
            except (KeyboardInterrupt, SystemExit):
                pass
        else:
            print("Usage: {} to check mail or {} -d to run as daemon".format(sys.argv[0],sys.argv[0]))
